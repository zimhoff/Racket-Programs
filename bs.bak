#lang racket
(require (prefix-in : parser-tools/lex-sre))
(require parser-tools/lex)
(require parser-tools/lex-sre)


(define basic-lexer
  (lexer
   [(eof) '()]

   [(:+ (:or (char-range #\a #\z)(char-range #\A #\Z)))
        (cons (ID, (string->symbol lexeme))
              (basic-lexer input-port))]
 ;  [#\:
  ;  (cons (1_ASS_OP, (string->symbol lexeme))
   ;       (basic-lexer input-port))]
   ;[#=
    ;(cons (2_ASS_OP, (string->symbol lexeme))
     ;     (basic-lexer input-port))]
   [#\(
    (cons (LPAR, (string->symbol lexeme))
          (basic-lexer input-port))]
   [#\)
    (cons (RPAR, (string->symbol lexeme))
          (basic-lexer input-port))]
   [#\-
    (cons (OP, (string->symbol lexeme))
          (basic-lexer input-port))]
   [#\$
    (cons (END, (string->symbol lexeme))
          (basic-lexer input-port))]
   [(:or #\+ #\* #\- #\/)
    (cons (OP, (string->symbol lexeme))
          (basic-lexer input-port))]
   [(:: (:? #-)(:+ (char-range #\0 #\9)))
        (cons (INT)
             (basic-lexer input-port))]
   [(:+ (:or #\: #\=))
        (cons (ASS_OP, (string->symbol lexeme))
              (basic-lexer input-port))]
   [(:+ (:or #$ #$))
        (cons `(eof)
              (basic-lexer input-port))]
   [whitespace (basic-lexer input-port)]
   ))
(define parse (basic-lexer(open-input-file "input01.txt")));testing
parse ;testing